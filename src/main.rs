use std::{fs, io};
use structopt::StructOpt;

fn main() {
    let opt = Opt::from_args();

    // TODO: add debug
    // if opt.debug {
    //     std::env::set_var("RUST_LOG", "debug");
    //     env_logger::init();
    // }



}

#[derive(StructOpt, Debug)]
#[structopt(about = "TODO: add some details")]
pub(crate) struct Opt {
    // flag to mark beginning of a snippet
    begin: String,

    // flag to mark ending of a snippet
    end: String,
    //
    // defaults to ./snippets/
    output_dir: String,
    // extension for generated files
    // defaults to .md / .mdx / .adoc ?
    extension: String,

    // default to current directory
    source_dir: String

    // excludes
    // includes
}


// func main() {
// fs := flag.NewFlagSet("snippet-extract", flag.ContinueOnError)
// opts := options{}
// opts.AddFlagSets(fs)
// if err := fs.Parse(os.Args[1:]); err != nil {
// fs.Usage()
// os.Exit(1)
// }
// wd, _ := os.Getwd()
// fmt.Printf("working from %s\n", wd)
// opts.filenames = extactFilenames(fs.Args())
// for _, filename := range opts.filenames {
// ext := filepath.Ext(filename)
// snippets := extractSnippets(opts.begin, opts.end, filename)
// for _, snippet := range snippets {
// outputFile := filepath.Join(opts.outputDir, filepath.Base(filename), snippet.Identifier+opts.extension)
// folder := filepath.Dir(outputFile)
// err := os.MkdirAll(folder, os.ModePerm)
// if err != nil {
// log.Printf("cannot mkdir %s: %s", folder, err)
// }
// f := bytes.NewBuffer(nil)
// fmt.Fprintf(f, `<!-- Code generated by snippet-extractor %s; DO NOT EDIT MANUALLY -->`, strings.Join(os.Args[1:], " "))
// fmt.Fprintf(f, "\n\n```%s\n%s```\n", ext, snippet.Text)
// err = ioutil.WriteFile(outputFile, f.Bytes(), 0600)
// if err != nil {
// log.Printf("cannot write %s in %s: %s", filepath.Base(outputFile), folder, err)
// }
// }
// }
// }