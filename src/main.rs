use std::{fs, io};
use structopt::StructOpt;
use snippext::extract_snippets;
use std::path::{PathBuf, Path};
use walkdir::WalkDir;

fn main() {
    let opt = Opt::from_args();

    // TODO: add debug
    // if opt.debug {
    //     std::env::set_var("RUST_LOG", "debug");
    //     env_logger::init();
    // }

    let filenames = get_filenames(opt.sources);
    for filename in filenames {
        let snippets = extract_snippets(opt.begin, opt.end, filename)
        // snippets := extractSnippets(opts.begin, opts.end, filename)

    }

}

// if an entry is a directory all files from directory will be listed.
fn get_filenames(sources: Vec<String>) -> Vec<PathBuf> {
    let mut out: Vec<PathBuf> = Vec::new();

    for source in sources {
        let path = Path::new(&source);
        if !path.is_dir() {
            out.push(path.to_path_buf())
        }

        for entry in WalkDir::new(&source)
            .into_iter()
            .filter_map(Result::ok)
            .filter(|e| !e.file_type().is_dir()) {
            out.push(entry.path().to_path_buf());
        }
    }

    out
}

#[derive(StructOpt, Debug)]
#[structopt(about = "TODO: add some details")]
struct Opt {
    // flag to mark beginning of a snippet
    begin: String,

    // flag to mark ending of a snippet
    end: String,
    //
    // defaults to ./snippets/
    output_dir: String,
    // extension for generated files
    // defaults to .md / .mdx / .adoc ?
    extension: String,

    // default to current directory
    sources: Vec<String>

    // excludes
    // includes
}


// func main() {
// fs := flag.NewFlagSet("snippet-extract", flag.ContinueOnError)
// opts := options{}
// opts.AddFlagSets(fs)
// if err := fs.Parse(os.Args[1:]); err != nil {
// fs.Usage()
// os.Exit(1)
// }
// wd, _ := os.Getwd()
// fmt.Printf("working from %s\n", wd)
// opts.filenames = extactFilenames(fs.Args())
// for _, filename := range opts.filenames {
// ext := filepath.Ext(filename)
// snippets := extractSnippets(opts.begin, opts.end, filename)
// for _, snippet := range snippets {
// outputFile := filepath.Join(opts.outputDir, filepath.Base(filename), snippet.Identifier+opts.extension)
// folder := filepath.Dir(outputFile)
// err := os.MkdirAll(folder, os.ModePerm)
// if err != nil {
// log.Printf("cannot mkdir %s: %s", folder, err)
// }
// f := bytes.NewBuffer(nil)
// fmt.Fprintf(f, `<!-- Code generated by snippet-extractor %s; DO NOT EDIT MANUALLY -->`, strings.Join(os.Args[1:], " "))
// fmt.Fprintf(f, "\n\n```%s\n%s```\n", ext, snippet.Text)
// err = ioutil.WriteFile(outputFile, f.Bytes(), 0600)
// if err != nil {
// log.Printf("cannot write %s in %s: %s", filepath.Base(outputFile), folder, err)
// }
// }
// }
// }
